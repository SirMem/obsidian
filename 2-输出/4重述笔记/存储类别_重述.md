---
number headings: auto, first-level 1, max 6, 1.1
due: 2023-10-13
title: 存储类别_重述
tags:
  - C语言
  - 重述
---


> [!summary]+ summary
> 简要地介绍了计算机C语言存储类别的理念


# 1 🤔问题:
## 1.1 什么是存储类别
存储类别是描述变量在内存中的存储状态，有自动，寄存器，静态外部链接，静态内部链接，静态无链接。




# 2 🤔区别:




# 3 📘自我重述

## 3.1 对象
从硬件方面来看，被储存的每个值都占用一定的物理内存，C 语言把这样的一块内存称为对象（object）。对象可以存储一个或多个值。
从软件方面来看，程序需要一种方法访问对象。这可以通过声明变量来完成：如 int entity =3; 也就是说，变量是访问对象的

## 3.2 存储类别作用的基本要素
### 3.2.1 标识符
正如上述声明entity，该声明创建了一个名为entity的标识符(identifier)。该声明还提供了储存在对象中的值。标识符即是软件(C程序)指定硬件内存中的对象的方式，一般来说是变量。

### 3.2.2 左值
一般而言，那些指定对象(地址)的表达式被称为左值，被赋值的变量就有这种性质。
```
*pt既是表达式也是左值。ranks + 2 * entity既不是标识符（不是名称），也不是左值（它不指定内存位置上的内容）。但是表达式*(ranks + 2 * entity)是一个左值，因为它的确指定了特定内存位置的值，即ranks数组的第7个元素。
```

### 3.2.3 例子
```
example
考虑此声明:const char * pc = "Behold a string literal!";
程序根据该声明把相应的字符串字面量储存在内存中，内含这些字符值
的数组就是一个对象。
由于数组中的每个字符都能被单独访问，所以每个字符也是一个对象
该声明还创建了一个标识符为pc的对象，储存着字符串的地址
由于可以设置pc重新指向其他字符串，所以标识符pc是一个可修改的左值。
const只能保证被pc指向的字符串内容不被修改，但是无法保证pc不指向别的字符串。由于*pc指定了储存'B'字符的数据对象，所以*pc 是一个左值，但不是一个可修改的左值。与此类似，因为字符串字面量本身指定了储存字符串的对象，所以它也是一个左值，但不是可修改的左值。
```

## 3.3 作用域
作用域即是一个变量的作用范围。一个C变量的作用域可以是块作用域、函数作用域、函数原型作用域或文件作用域。

### 3.3.1 块作用域
在 {} 之间定义的 js 代码是块级作用域。即在块级作用域里定义的变量是块级变量，只在该块级作用域中有效。C99把块的概念扩展到包括for循环、while循环、do while循环和if语句所控制的代码，即使这些代码没有用花括号括起来，也算是块的一部分。for循环中的变量i被视为for循环块的一部分，它的作用域仅限于for循环。一旦程序离开for循环，就不能再访问i。

### 3.3.2 函数作用域
函数作用域也称为局部作用域。调用函数时创建函数作用域，函数执行完毕后，函数作用域销毁。定义在函数内部的变量只能在函数内部访问，不能在函数以外去访问。
在函数作用域中可以访问到文件作用域中的变量；在文件作用域中无法访问到函数作用域的变量。当在函数作用域中操作一个变量时，它会先在自身的作用域中去找，若有则直接使用；若没有则向上一级作用域中寻找。直接找到文件作用域，若文件作用域仍未找到，则直接报错

### 3.3.3 函数原型作用域
函数原型作用域（function prototype scope）用于函数原型中的形参名。函数原型作用域的范围是从形参定义处到原型声明结束。
### 3.3.4 文件作用域
任何在所有代码块之外声明的标识符都具有文件作用域(file scope)。它表示这些标识符从它们的声明之处直到它所在的源文件结尾处都是可以访问的。在文件中定义的函数名也具有文件作用域，因为函数名本身并不属于任何代码块。
#### 3.3.4.1 内部文件作用域
描述仅限于一个翻译单元（即一个源代码文件和它所包含的头文件）的作用域
#### 3.3.4.2 外部文件作用域(全局定义域)
“外部链接的文件作用域”描述可延伸至其他翻译单元的作用域。

## 3.4 翻译单元和文件
编译器源代码文件和所有的头文件都看成是一个包含信息的单独文件。这个文件被称为翻译单元（translation unit）。
描述一个具有文件作用域的变量时，它的实际可见范围是整个翻译单元。如果程序由多个源代码文件组成，那么该程序也将由多个翻译单元组成。每个翻译单元均对应一个源代码文件和它所包含的文件。



## 3.5 链接
链接（linking）是将多个源文件编译生成的目标文件或库文件组合成一个可执行文件或可加载模块的过程。这个过程包括解析符号引用（例如函数、变量等），并将它们与其定义进行关联，最终生成可执行代码的过程。
C 变量有 3 种链接属性：外部链接、内部链接或无链接。
具有块作用域、函数作用域或函数原型作用域的变量都是无链接变量。这意味着这些变量属于定义它们的块、函数或原型私有。
具有文件作用域的变量可以是外部链接或内部链接。外部链接变量可以在多文件程序中使用，内部链接变量只能在一个翻译单元中使用
### 3.5.1 链接的分辨
通过[[存储类别_重述#存储类别说明符|存储类别说明符]]查看外部定义中是否使用了存储类别说明符static
![[nPpXHawlbwqKtrsN-b5e4ce1e-2b98-f7ad-e250-ad3ab89e0fc6.png]]
外部链接可以没有存储类别说明符。
## 3.6 存储类别说明符
[[存储类别_重述#存储期|存储期]]
C语言有6个关键字作为存储类别说明符：auto、register、static、extern、\_Thread_local和typedef。
auto说明符表明变量是自动存储期，只能用于块作用域的变量声明中。由于在块中声明的变量本身就具有自动存储期，所以使用auto主要是为了明确表达要使用与外部变量同名的局部变量的意图。自动变量不会初始化，除非显式初始化它
static 说明符创建的对象具有静态存储期，载入程序时创建对象，当程序结束时对象消失。如果static 用于文件作用域声明，作用域受限于该文件，即产生了内部链接。如果 static 用于块作用域声明，作用域则受限于该块，即无链接。
extern 说明符表明声明的变量定义在别处。如果包含 extern 的声明具有文件作用域，则引用的变量必须具有外部链接。如果包含 extern 的声明具有块作用域，则引用的变量可能具有外部链接或内部链接，这接取决于该变量的定义式声明。
register存储类别说明符可声明寄存器变量，因为声明变量为register类别与直接命令
相比更像是一种请求。编译器必须根据寄存器或最快可用内存的数量衡量你的请求，或者直接忽略你的请求，所以可能不会如你所愿。在这种情况下，寄存器变量就变成普通的自动变量(auto)。即使是这样，仍然不能对该变量使用地址运算符。可声明为register的数据类型有限。例如，处理器中的寄存器可能没有足够大的空间来储存double类型的值。
## 3.7 存储期
[[存储类别_重述#存储类别说明符|存储类别说明符]]
作用域和链接描述了标识符的可见性。存储期描述了通过这些标识符访问的对象的生存期。C对象有4种存储期：静态存储期、线程存储期、自动存储期、动态分配存储期。存储期是指对象在内存中保留了多长时间.
### 3.7.1 静态存储期
如果对象具有静态存储期，那么它在程序的执行期间一直存在。文件作用域变量具有静态存储期。注意，对于文件作用域变量，关键字 static表明了其链接属性(内部)，而非存储期。以 static声明的文件作用域变量具有内部链接。但是无论是内部链接还是外部链接，所有的文件作用域变量都具有静态存储期。

### 3.7.2 线程存储期
线程存储期用于并发程序设计，程序执行可被分为多个线程。具有线程存储期的对象，从被声明时到线程结束一直存在。以关键字_Thread_local声明一个对象时，每个线程都获得该变量的私有备份。

### 3.7.3 自动存储期
块作用域的变量通常都具有自动存储期。当程序进入定义这些变量的块时，为这些变量分配内存；当退出这个块时，释放刚才为变量分配的内存。这种做法相当于把自动变量占用的内存视为一个可重复使用的工作区或暂存区。例如，一个函数调用结束后，其变量占用的内存可用于储存下一个被调用函数的变量。
变长数组稍有不同，它们的存储期从声明处到块的末尾，而不是从块的开始处到块的末尾。

## 3.8 块作用域的存储期
我们到目前为止使用的局部变量都是自动类别。例如，在下面的代码中，变量number和index在每次调用bore()函数时被创建，在离开函数时被销毁
```
void bore(int number)
{
int index;
for (index = 0;index < number;index++)
puts("They don't make them the way they used to.\n");
return 0;
}
```
然而，块作用域变量也能具有静态存储期。为了创建这样的变量，要把
变量声明在块中，且在声明前面加上关键字static
```
void more(int number)
{
int index;
static int ct = 0;+
...
return 0;
}
```
这里，变量ct储存在静态内存中，它从程序被载入到程序结束期间都存
在。但是，它的作用域定义在more()函数块中。只有在执行该函数时，程序
才能使用ct访问它所指定的对象（但是，该函数可以给其他函数提供该存储
区的地址以便间接访问该对象，例如通过指针形参或返回值）

## 3.9 存储类别、作用域、存储期、链接、声明方式总结
C 使用作用域、链接和存储期为变量定义了多种存储方案。本书不涉及
并发程序设计，所以不再赘述这方面的内容。已分配存储期在本章后面介
绍。因此，剩下5种存储类别：自动、寄存器、静态块作用域、静态外部链
接、静态内部链接
![[nPpXHawlbwqKtrsN-85e625b7-c654-1add-ff60-5a20b9e6ac67.png|986]]
块作用域和无链接意味着只有在变量定义所在的块中才能通过变量名访问该变量（当然，参数用于传递变量的值和地址给另一个函数，但是这是间接的方法）。另一个函数可以使用同名变量，但是该变量是储存在不同内存位置上的另一个变量。
变量具有自动存储期意味着，程序在进入该变量声明所在的块时变量存在，程序在退出该块时变量消失。原来该变量占用的内存位置现在可做他用。


## 3.10 嵌套块
```
块中声明的变量仅限于该块及其包含的块使用。
int loop(int n)
{
int m; // m 的作用域
scanf("%d", &m);

{
int i; // m 和 i 的作用域
for (i = m;i < n;i++)
puts("i is local to a sub-block\n");

}

return m; // m 的作用域，i 已经消失
}
```
如果内层块中声明的变量与外层块中的变量同名会怎样？内层块会隐藏
外层块的定义。但是离开内层块后，外层块变量的作用域又回到了原来的作用域。

## 3.11 静态变量对作用域及链接的影响
[[存储类别_重述#存储类别说明符|存储类别说明符]]
### 3.11.1 块作用域的静态变量
静态的意思是该变量在内存中原地不动，并不是说它的值不变。具有文件作用域的变量自动具有（也必须是）静态存储期。前面提到过，可以创建具有静态存储期、块作用域的局部变量。这些变量和自动变量一样，具有相同的作用域，但是程序离开它们所在的函数后，这些变量不会消失。也就是说，这种变量具有块作用域、无链接，但是具有静态存储期。
不能在函数的形参中使用static

### 3.11.2 外部链接的静态变量
[[存储类别_重述#外部变量|外部变量]]
外部链接的静态变量具有文件作用域、外部链接和静态存储期。该类别有时称为外部存储类别（external storage class），属于该类别的变量称为外部变量（external variable）。把变量的定义性声明（defining declaration）放在在所有函数的外面便创建了外部变量。为了指出该函数使用了外部变量，可以在函数中用关键字extern再次声明。如果一个源代码文件使用的外部变量定义在另一个源代码文件中，则必须用extern在该文件中声明该变量。
```
example:
int Errupt; /* 外部定义的变量 */
double Up[100];/* 外部定义的数组 */
extern char Coal;/* 如果Coal被定义在另一个文件， */
/*则必须这样声明*/
void next(void);
int main(void)
{
extern int Errupt;/* 可选的声明*/
extern double Up[];/* 可选的声明*/
...

}
void next(void)
{
...
}
```
注意，在main()中声明Up数组时（这是可选的声明）不用指明数组大
小，因为第1次声明已经提供了数组大小信息。
```
如果省略掉函数中的extern关键字，相当于创建了一个自动变量。去掉
下面声明中的extern
extern int Errupt;
便成为：
int Errupt;
```
这使得编译器在 main()中创建了一个名为 Errupt 的自动变量。它是一个独立的局部变量，与原来的外部变量Errupt不同。该局部变量仅main()中可见，但是外部变量Errupt对于该文件的其他函数（如 next()）也可见。简而言之，在执行块中的语句时，块作用域中的变量将“隐藏”文件作用域中的同名变量。如果不得已要使用与外部变量同名的局部变量，可以在局部变量的声明中使用 auto 存储类别说明符明确表达这种意图。

### 3.11.3 内部链接的静态变量
该存储类别的变量具有静态存储期、文件作用域和内部链接。在所有函数外部（这点与外部变量相同），用存储类别说明符<font color="#f79646">static定义</font>的变量具有这种存储类别
```
example
static int svil = 1; // 静态变量，内部链接
int main(void){

}
```
这种变量过去称为外部静态变量（external static variable），但是这个
术语有点自相矛盾（这些变量具有内部链接）。但是，没有合适的新简称，
所以只能用内部链接的静态变量（static variable with internal linkage）。
```
example
int traveler = 1; // 外部链接
static int stayhome = 1; // 内部链接
int main()
{
extern int traveler;// 使用定义在别处的 traveler
extern int stayhome; // 使用定义在别处的 stayhome
...
```
对于该程序所在的翻译单元，trveler和stayhome都具有文件作用域，但是只有traveler可用于其他翻译单元（因为它具有外部链接）。这两个声明都使用了extern关键字，指明了main()中使用的这两个变量的定义都在别处，但是这并未改变stayhome的内部链接属性。
## 3.12 外部变量
### 3.12.1 初始化外部变量
外部变量和自动变量类似，也可以被显式初始化。与自动变量不同的
是，如果未初始化外部变量，它们会被自动初始化为 0。与自动变量的情况不同，只能使用常量表达式初始化
文件作用域变量
```
example
int x = 10; // 没问题，10是常量
int y = 3 + 20; // 没问题，用于初始化的是常量表达式
size_t z = sizeof(int); //没问题，用于初始化的是常量表达式
int x2 = 2 * x; // 不行，x是变量
（只要不是变长数组，sizeof表达式可被视为常量表达式。）
```

### 3.12.2 使用外部变量
```
example
/* global.c -- 使用外部变量 */
#include <stdio.h>
int units = 0;
/* 外部变量 */
void critic(void);
int main(void)
{
extern int units; /* 可选的重复声明 */
printf("How many pounds to a firkin of butter?\n");
scanf("%d", &units);
while (units != 56)
critic();
printf("You must have looked it up!\n");
return 0;
}
void critic(void)
{
/* 删除了可选的重复声明 */
printf("No luck, my friend. Try again.\n");
scanf("%d", &units);
}
下面是该程序的输出示例：
How many pounds to a firkin of butter?
14
No luck, my friend. Try again.
56
You must have looked it up!
```

while循环结束时，
main()也知道units的新值。所以main()函数和critic()都可以通过标识符units访
问相同的变量。用C的术语来描述是， units具有文件作用域、外部链接和静
态存储期。

把units定义在所有函数定义外面（即外部），units便是一个外部变量，
对units定义下面的所有函数均可见。因此，critics()自定函数可以直接使用units变量。

本例中，以上声明主要是为了指出该函数要使用这个外部变量。存储类
别说明符extern告诉编译器，该函数中任何使用units的地方都引用同一个定
义在函数外部的变量。再次强调，main()和critic()使用的都是外部定义的
units。

### 3.12.3 外部名称限定
C99和C11标准都要求编译器识别局部标识符的前63个字符和外部标识
符的前31个字符。这修订了以前的标准，即编译器识别局部标识符前31个字
符和外部标识符前6个字符。你所用的编译器可能还执行以前的规则。外部
变量名比局部变量名的规则严格，是因为外部变量名还要遵循局部环境规
则，所受的限制更多。

### 3.12.4 定义和声明
```
example
int tern = 1; /* tern被定义 */
main()
{
extern int tern; /* 使用在别处定义的tern */
```
这里，tern被声明了两次。第1次声明为变量预留了存储空间，该声明构
成了变量的定义。第2次声明只告诉编译器使用之前已创建的tern变量，所以
这不是定义。第1次声明被称为定义式声明（defining declaration），第2次声
明被称为引用式声明（referencing declaration）。关键字extern表明该声明不
是定义，因为它指示编译器去别处查询其定义。
```
假设这样写
extern int tern;
int main(void)
{
```
编译器会假设 tern 实际的定义在该程序的别处，也许在别的文件中。该
声明并不会引起分配存储空间。因此，不要用关键字extern创建外部定义，
只用它来引用现有的外部定义。

```
只能定义一次
// file_one.c
char permis = 'N';
...
// file_two.c
extern char permis = 'Y'; /* 错误 */
```
file_two中的声明是错误的，因为file_one.c中的定义式声明已经创建并
初始化了permis。

## 3.13 多文件
只有当程序由多个翻译单元组成时，才体现区别内部链接和外部链接的重要性。
复杂的C程序通常由多个单独的源代码文件组成。要共享一个外部变量。C通过在一个文件中进行定义式声明，然后在其他文件中进行引用式声明来实现共享。也就是说，除了一个定义式声明外，其他声明都要使用extern关键字。而且，只有定义式声明才能初始化变量。
如果外部变量定义在一个文件中，那么其他文件在使用该变量之前必须先声明它（用 extern关键字）。也就是说，在某文件中对外部变量进行定义式声明只是单方面允许其他文件使用该变量，其他文件在用extern声明之前不能直接使用它。

## 3.14 函数的存储类别
函数也有存储类别，可以是外部函数（默认）或静态函数。C99 新增了
第 3 种类别——内联函数;
外部函数可以被其他文件的函数访问，但是静态函数只能用于其定义所在的文件
```
example
double gamma(double); /* 该函数默认为外部函数 */
static double beta(int,int);
extern double delta(double,int);
```
在同一个程序中，其他文件中的函数可以调用gamma()和delta()，但是不能调用beta()，因为以static存储类别说明符创建的函数属于特定模块私有。这样做避免了名称冲突的问题，由于beta()受限于它所在的文件，所以在其他文件中可以使用与之同名的函数。
通常的做法是：用 extern 关键字声明定义在其他文件中的函数。这样做
是为了表明当前文件中使用的函数被定义在别处。除非使用static关键字，
否则一般函数声明都默认为extern。

## 3.15 存储类别的选择
对于“使用哪种存储类别”的回答绝大多数是“自动存储类别”，要知道默认类别就是自动存储类别。初学者会认为外部存储类别很不错，为何不把所有的变量都设置成外部变量，这样就不必使用参数和指针在函数间传递信息了。然而，这背后隐藏着一个陷阱。如果这样做，A()函数可能违背你的意图，私下修改B()函数使用的变量。多年来，无数程序员的经验表明，随意使用外部存储类别的变量导致的后果远远超过了它所带来的便利。
唯一例外的是const数据。因为它们在初始化后就不会被修改，所以不用担心它们被意外篡改
保护性程序设计的黄金法则是：“按需知道”原则。尽量在函数内部解决该函数的任务，只共享那些需要共享的变量。除自动存储类别外，其他存储类别也很有用。不过，在使用某类别之前先要考虑一下是否有必要这样做。