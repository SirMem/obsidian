---
due: 2023-10-31 

title: 各类函数的特点_重述
tags:
 
- c语言 重述
---


> [!summary]+ summary
> 简要说明了各类函数的使用，以及示例


# 🤔问题:
## 阐述一下各类函数特点的应用场景




# 🤔相关联:
[[指针_重述#各类型的指针]]



# 📘自我重述
## 库函数
- 这些函数是C标准库（如stdio.h、stdlib.h、string.h等）中定义的函数。
- 它们是预定义的，可以直接在C程序中使用。
- 用于执行常见的任务，如输入/输出、内存分配、字符串处理等。
- 通常不需要自己实现，只需包含相应的头文件并调用这些函数。

## 自定函数
- 这些函数由程序员自己编写，用于实现特定的功能或任务。
- 允许将程序分解为更小的、可维护的块，以提高代码的可读性和重用性。
- 用户自定义函数必须在使用之前进行声明或定义。

## 递归函数
 - 递归函数是可以调用自身的函数。
- 递归通常用于解决需要重复执行相似操作的问题，如树遍历或阶乘计算。
- 需要小心，确保递归不会无限循环，并具有终止条件。

### 使用
递归函数包括两个部分：基本情况和递归情况。基本情况(通常是判断语句)是当函数遇到一个可以直接解决的问题时停止递归，而递归情况是函数在解决问题时调用自身，但问题规模比原问题更小，这将最终导致基本情况的出现。
### 示例
```
#include <stdio.h>

int factorial(int n) {
    // 基本情况
    if (n == 0) {
        return 1;
    }
    // 递归情况
    else {
        return n * factorial(n - 1);
    }
}

int main() {
    int num = 5;
    int result = factorial(num);
    printf("%d的阶乘是：%d\n", num, result);
    return 0;
}
```
`factorial` 函数通过递归方式计算输入整数 `n` 的阶乘。基本情况是 `n` 为0时，返回1，这是递归的停止条件。
例如，如果我们调用 `factorial(5)`，它将执行如下递归调用序列：
```
1. `factorial(5)` 返回 5 * `factorial(4)`
2. `factorial(4)` 返回 4 * `factorial(3)`
3. `factorial(3)` 返回 3 * `factorial(2)`
4. `factorial(2)` 返回 2 * `factorial(1)`
5. `factorial(1)` 返回 1 * `factorial(0)`
6. `factorial(0)` 触发基本情况，返回1。
```
然后，这些值从内部递归调用中传递回来，依次相乘，得到 `factorial(5)` 的结果为 120。

### 应用
1. 阶乘计算：
   递归函数可以用于计算一个整数的阶乘。阶乘是一个自然数 n 的乘积，从1到 n。例如，5的阶乘是5! = 5 * 4 * 3 * 2 * 1 = 120。

   ```c
   int factorial(int n) {
       if (n <= 1) {
           return 1;
       } else {
           return n * factorial(n - 1);
       }
   }
   ```

2. 斐波那契数列：
   递归函数也可以用于计算斐波那契数列中的第 n 个数。斐波那契数列的定义是：F(0) = 0, F(1) = 1，F(n) = F(n-1) + F(n-2)（对于 n > 1）。

   ```c
   int fibonacci(int n) {
       if (n <= 1) {
           return n;
       } else {
           return fibonacci(n - 1) + fibonacci(n - 2);
       }
   }
   ```

3. 文件系统遍历：
   递归函数可以用于遍历文件系统中的目录和文件。这对于文件管理器等应用程序非常有用。

4. 二叉树操作：
   递归函数在处理二叉树时也非常常见，如树的遍历（前序、中序、后序遍历）、查找节点、插入节点等。

5. 数据排序：
   递归算法，如归并排序和快速排序，通常使用递归函数来实现。这些算法将数据分成更小的部分，递归地排序它们，然后合并它们以获得排序的结果。

6. 汉诺塔问题：
   汉诺塔问题是一个经典的递归问题，其中你需要将一堆盘子从一个杆子移动到另一个杆子，遵循一定规则。

## 回调函数
- 回调函数是作为参数传递给另一个函数的函数，并且可以在需要的时候由另一个函数来调用。
- 回调函数的主要作用是允许您将特定的功能或行为以函数的形式传递给另一个函数，从而增加了程序的灵活性和可扩展性。
- 回调函数通常结合函数指针使用
### 示例
```c
#include <stdio.h>

// 回调函数类型
typedef int (*Operation)(int, int);

// 使用回调函数的函数
int operate(int a, int b, Operation op) {
    return op(a, b);
}

// 实际回调函数
int add(int a, int b) {
    return a + b;
}

int subtract(int a, int b) {
    return a - b;
}

int main() {
    int result;
    result = operate(5, 3, add);      // 使用add函数
    printf("Result: %d\n", result);
    result = operate(5, 3, subtract); // 使用subtract函数
    printf("Result: %d\n", result);
    return 0;
}

```
这个示例演示了如何使用回调函数，通过向`operate`函数传递不同的函数来执行不同的操作。
## 指针函数
- 指针函数是指返回类型的值是指针

## 静态函数
- 静态函数的作用域仅限于定义它的源文件。
- 通常用于隐藏函数的实现细节，使其对其他文件不可见。
- 有助于避免函数名冲突。

# 💻代码区