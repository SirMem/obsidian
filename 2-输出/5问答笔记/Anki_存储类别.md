---
cards-deck: 2-输出::5问答笔记
tags:
  - Anki
  - C语言
---


#card


# 摘录挖空区
## 对象
从硬件方面来看，被储存的每个值都占用一定的物理内存，C 语言把这样的一块内存称为==对象（object）==。==对象==可以存储一个或多个值。
^1697180559576
从软件方面来看，程序需要一种方法访问对象。这可以通过==声明变量==来完成：如 int entity =3; 也就是说，变量是访问对象的
^1697180559585
## 存储类别作用的基本要素
### 标识符
正如上述声明entity，该声明创建了一个名为entity的标识符(identifier)。该声明还提供了储存在对象中的值。==标识符==即是软件(C程序)==指定硬件内存中==的对象的方式，一般来说是==变量==。
^1697180675970
### 左值
一般而言，那些==指定对象(地址)的表达式==被称为左值，==被赋值的变量==就有这种性质。
^1697180675976
\*pt既是表达式也是左值。ranks + 2 * entity既不是标识符（不是名称），也不是左值（它不==指定内存位置上==的内容）。但是表达式*(ranks + 2 * entity)是一个左值，因为它的确指定了==特定内存位置==的值，即ranks数组的第7个元素。
^1697181379290

### 例子
考虑此声明:const char * pc = "Behold a string literal!";程序根据该声明把相应的字符串字面量储存在内存中，内含这些字符值的数组就是一个对象。由于数组中的每个字符都能被单独访问，所以每个字符也是一个对象。该声明还创建了一个标识符为pc的对象，储存着字符串的地址。
由于可以设置pc重新指向其他字符串，所以标识符pc是一个可修改的左值。
const只能保证被pc指向的字符串内容==不被修改==，但是无法保证pc不指向别的字符串。由于*pc指定了储存'B'字符的数据对象，所以*pc 是一个左值，但不是一个可修改的左值。与此类似，因为字符串字面量本身指定了储存字符串的对象，所以它也是一个左值，但不是可修改的左值。
^1697181379312

## 作用域
作用域即是一个变量的作用范围。一个C变量的作用域可以是==块作用域、函数作用域、函数原型作用域或文件作用域==。
^1697181379323
### 块作用域
在 =={} 之间定义的 js 代码==是块级作用域。即在块级作用域里定义的变量是==块级变量==，只在该块级作用域中有效。C99把块的概念扩展到包括==for循环、while循环、do while循环和if语句所控制的代码==，即使这些代码没有用==花括号==括起来，也算是块的一部分。for循环中的变量i被视为for循环块的==一部分==，它的作用域仅限于for循环。一旦程序离开for循环，就不能再访问i。
^1697181379328

### 函数作用域
函数作用域也称为局部作用域。调用函数时==创建函数作用域==，函数执行完毕后，函数作用域==销毁==。定义在函数内部的变量只能在函数==内部访问==，不能在函数以外去==访问==。
^1697181379334
在函数作用域中可以访问到==文件作用域==中的变量；在文件作用域中无法访问到==函数作用域==的变量。当在函数作用域中操作一个变量时，它会先在==自身的作用域==中去找，若有则直接使用；若没有则向==上一级作用域==中寻找。直接找到==文件作用域==，若文件作用域仍未找到，则直接报错
^1697181379340

### 函数原型作用域
函数原型作用域（function prototype scope）用于函数原型中的==形参名==。函数原型作用域的范围是从形参定义处到原型声明结束。
^1697181379344
### 文件作用域
任何在==所有代码块之外==声明的标识符都具有文件作用域(file scope)。在一个文件中它表示这些标识符从它们的声明之处直到它所在的源文件结尾处都是可以访问的。在文件中定义的函数名也具有==文件作用域==，因为函数名本身并不属于任何代码块。
^1697181379350
#### 内部文件作用域
描述仅限于一个翻译单元（即==一个源代码文件和它所包含的头文件==）的作用域
^1697181379355
#### 外部文件作用域(全局定义域)
“外部链接的文件作用域”描述可延伸至==其他翻译单元==的作用域，也就是多个翻译单元的作用域。
^1697181379361
## 翻译单元和文件
编译器==源代码文件和所有的头文件==都看成是一个包含信息的单独文件。这个文件被称为翻译单元（translation unit）。
^1697182109352
描述一个具有文件作用域的变量时，它的实际可见范围是整个翻译单元。如果程序由多个源代码文件组成，那么该程序也将由多个翻译单元组成。每个翻译单元均对应==一个源代码文件和它所包含的文件==。
^1697182109371

## 链接
C 变量有 3 种链接属性：==外部链接、内部链接或无链接==。
^1697182109378
具有块作用域、函数作用域或函数原型作用域的变量都是==无链接变量==。这意味着这些变量属于定义它们的块、函数或原型==私有==。
^1697182109385
具有文件作用域的变量可以是外部链接或==内部==链接。外部链接变量可以在==多文件程序中==使用，内部链接变量只能在==一个翻译单元==中使用
^1697182109390
### 链接的分辨
通过[[存储类别_重述#存储类别说明符|存储类别说明符]]查看外部定义中是否使用了存储类别说明符static，若使用static即为使用了==内部链接==。
^1697182109395
![[nPpXHawlbwqKtrsN-b5e4ce1e-2b98-f7ad-e250-ad3ab89e0fc6.png]]
外部链接可以没有==存储类别说明符==。
^1697182109400
## 存储类别说明符
C语言有6个关键字作为存储类别说明符：==auto、register、static、extern、\_Thread_local和typedef。==
^1697182109406
auto说明符表明变量是==自动存储期==，只能用于==块作用域的变量声明中==。由于在块中声明的变量==本身就具有自动存储期==，所以使用auto主要是为了==明确表达要使用与外部变量同名的局部变量的意图==。自动变量不会初始化，除非==显式初始化==它
^1697182109411
static 说明符创建的对象具有==静态存储期==，载入程序时==创建对象==，当程序结束时==对象消失==。如果static 用于==文件作用域声明==，作用域==受限于该文件==，即产生了内部链接。如果 static 用于块作用域声明，==作用域则受限于该块==，即无链接。
^1697182109416
extern 说明符表明声明的变量定义在别处。如果包含 extern 的声明具有==文件作用域==，则引用的变量必须具有==外部链接==。如果包含 extern 的声明具有块作用域，则引用的变量可能具有==外部链接或内部链接==，这接取决于该变量的==定义式声明==。
^1697182109420
register存储类别说明符可声明==寄存器变量==，因为声明变量为register类别与直接命令
^1697182109425
相比==更像是一种请求==。编译器必须根据==寄存器或最快可用内存的数量==衡量你的请求，或者==直接忽略你的请求==，所以可能不会如你所愿。在这种情况下，寄存器变量就变成普通的==自动变量(auto)==。即使是这样，仍然不能对该变量使用地址运算符。可声明为register的数据类型==有限==。例如，处理器中的寄存器可能没有足够大的空间来储存double类型的值。
^1697182109430

## 存储期
[[存储类别_重述#存储类别说明符|存储类别说明符]]
作用域和链接描述了标识符的可见性。存储期描述了通过这些标识符访问的对象的生存期。C对象有4种存储期：==静态存储期、线程存储期、自动存储期、动态分配存储期。==存储期是指==对象在内存中保留了多长时间==.
^1697182394367
### 静态存储期
如果对象具有静态存储期，那么它在程序的执行期间==一直存在==。==文件作用域变量==具有静态存储期。注意，对于文件作用域变量，关键字 static表明了其==链接属性==(内部)，而非存储期。以 static声明的文件作用域变量==具有内部链接==。但是无论是内部链接还是外部链接，所有的文件作用域变量都具有==静态存储期==。
^1697182394387

### 线程存储期
线程存储期用于==并发程序设计==，程序执行可被分为多个线程。具有线程存储期的对象，从被声明时到线程结束一直存在。以关键字_Thread_local声明一个对象时，每个线程都获得该变量的私有备份。
^1697182394395

### 自动存储期
==块作用域的变量==通常都具有自动存储期。当程序进入定义这些变量的块时，为这些变量==分配内存==；当退出这个块时，==释放刚才为变量分配的内存==。这种做法相当于把自动变量占用的内存==视为一个可重复使用的工作区或暂存区==。例如，一个函数调用结束后，其变量占用的内存可用于==储存==下一个被调用函数的变量。
^1697182394403
变长数组稍有不同，它们的存储期从声明处到块的末尾，而不是从块的开始处到块的末尾。

## 块作用域的存储期
[[存储类别_重述#存储期|存储期]]
我们到目前为止使用的局部变量都是自动类别。例如，在下面的代码中，变量number和index在每次调用bore()函数时被创建，在离开函数时被==销毁==
^1697182925815
void bore(int number)
{
int index;
for (index = 0;index < number;index++)
puts("They don't make them the way they used to.\n");
return 0;
}
然而，块作用域变量也能具有静态存储期。为了创建这样的变量，要把变量声明在块中，且在声明前面加上关键字==static==
^1697182925837
void more(int number)
{
int index;
static int ct = 0;+
...
return 0;
}
这里，变量ct储存在静态内存中，它从程序被载入到程序结束期间都==存在==。但是，它的作用域定义在more()函数块中。只有在执行该函数时，程序才能使用ct访问它所指定的对象（但是，该函数可以给其他函数提供该存储区的地址以便间接访问该对象，例如通过==指针形参或返回值==）
^1697182925846

## 存储类别、作用域、存储期、链接、声明方式总结
C 使用作用域、链接和存储期为变量定义了多种存储方案。本书不涉及并发程序设计，所以不再赘述这方面的内容。已分配存储期在本章后面介绍。因此，剩下5种存储类别：==自动、寄存器、静态块作用域、静态外部链接、静态内部链接==
^1697182925852
![[nPpXHawlbwqKtrsN-85e625b7-c654-1add-ff60-5a20b9e6ac67.png|986]]
块作用域和无链接意味着==只有在变量定义所在的块中才能通过变量名访问该变量==（当然，参数用于传递变量的值和地址给另一个函数，但是这是间接的方法）。另一个函数可以使用同名变量，但是该变量是储存在==不同内存位置==上的另一个变量。
^1697182925857
变量具有自动存储期意味着，程序在进入该变量声明所在的块时变量==存在==，程序在退出该块时变量==消失==。原来该变量占用的内存位置现在==可做他用==。
^1697182925862

## 嵌套块
块中声明的变量仅限于该块及其包含的块使用。
int loop(int n)
{
int m; // m 的作用域
scanf("%d", &m);

{
int i; // m 和 i 的作用域
for (i = m;i < n;i++)
puts("i is local to a sub-block\n");

}

return m; // m 的作用域，i 已经消失
}
如果内层块中声明的变量与外层块中的变量同名会怎样？内层块会隐藏==外层块的定义==。但是离开内层块后，外层块变量的作用域又回到了原来的作用域。
^1697184738716

## 静态变量对作用域及链接的影响
[[存储类别_重述#存储类别说明符|存储类别说明符]]
###  块作用域的静态变量
静态的意思是该变量在内存中==原地不动==，并不是说它的值不变。具有文件作用域的变量自动具有（也必须是）==静态存储期==。前面提到过，可以创建具有静态存储期、块作用域的局部变量。这些变量和自动变量一样，具有相同的作用域，但是程序离开它们所在的函数后，这些变量不会消失。也就是说，这种变量具有块作用域、无链接，但是具有静态存储期。
^1697184738741
不能在函数的形参中使用static

### 外部链接的静态变量
[[存储类别_重述#外部变量|外部变量]]
外部链接的静态变量具有文件作用域、外部链接和静态存储期。该类别有时称为外部存储类别（external storage class），属于该类别的变量称为外部变量（external variable）。把变量的定义性声明（defining declaration）放在==在所有函数的外面==便创建了外部变量。为了指出该函数使用了外部变量，可以在函数中用关键字==extern再次声明==。如果一个源代码文件使用的外部变量定义在另一个源代码文件中，则必须用extern在该文件中==声明该变量==。
^1697184738749
==example:
int Errupt; /* 外部定义的变量 */
double Up[100];/* 外部定义的数组 */
extern char Coal;/* 如果Coal被定义在另一个文件， */
/*则必须这样声明*/
void next(void);
int main(void)
{
extern int Errupt;/* 可选的声明*/
extern double Up[];/* 可选的声明*/
...
}
void next(void)
{
...
} ==
注意，在main()中声明Up数组时（这是可选的声明）不用==指明==数组大小,因为第1次声明已经提供了数组大小信息。
^1697184738754


## 外部变量
### 初始化外部变量
外部变量和自动变量类似，也可以被显式初始化。与自动变量不同的是，如果未初始化外部变量，它们会被自动初始化为 0。与自动变量的情况不同，只能使用常量表达式初始化。不能使用==变量==初始化
^1697184738765
### 外部名称限定
C99和C11标准都要求编译器识别局部标识符的前63个字符和外部标识
符的前31个字符。这修订了以前的标准，即编译器识别局部标识符前31个字
符和外部标识符前6个字符。你所用的编译器可能还执行以前的规则。外部
变量名比局部变量名的规则严格，是因为外部变量名还要遵循局部环境规
则，所受的限制更多。

## 多文件
只有当程序由多个==翻译单元==组成时，才体现区别内部链接和外部链接的重要性。
^1697185325762
复杂的C程序通常由多个单独的源代码文件组成。要共享一个外部变量。C通过在一个文件中进行定义式声明，然后在其他文件中进行引用式声明来实现共享。也就是说，除了一个定义式声明外，其他声明都要使用extern关键字。而且，只有定义式声明才能初始化变量。
如果外部变量定义在一个文件中，那么其他文件在使用该变量之前必须先声明它（用 extern关键字）。也就是说，在某文件中对外部变量进行定义式声明只是单方面允许其他文件使用该变量，其他文件在用==extern声明==之前不能直接使用它。
^1697185325768


## 函数的存储类别
函数也有存储类别，可以是==外部函数（默认）或静态函数。C99 新增了第 3 种类别——内联函数==;
^1697185325773
外部函数可以被其他文件的函数==访问==，但是静态函数只能用于其定义==所在的文件==
^1697185325778
```
example
double gamma(double); /* 该函数默认为外部函数 */
static double beta(int,int);
extern double delta(double,int);
```
在同一个程序中，其他文件中的函数可以调用gamma()和delta()，但是不能调用beta()，因为以static存储类别说明符创建的函数属于特定模块私有。这样做避免了名称冲突的问题，由于beta()受限于它所在的文件，所以在其他文件中可以使用与之同名的函数。
通常的做法是：用 extern 关键字声明定义在其他文件中的函数。这样做
是为了表明当前文件中使用的函数被定义在别处。除非使用static关键字，
否则一般函数声明都默认为extern。

## 存储类别的选择
对于“使用哪种存储类别”的回答绝大多数是“自动存储类别”，要知道默认类别就是自动存储类别。初学者会认为外部存储类别很不错，为何不把所有的变量都设置成外部变量，这样就不必使用参数和指针在函数间传递信息了。然而，这背后隐藏着一个陷阱。如果这样做，A()函数可能==违背你的意图==，私下修改B()==函数使用的变量==。多年来，无数程序员的经验表明，随意使用外部存储类别的变量导致的后果远远超过了它所带来的便利。
^1697185325783
唯一例外的是==const数据==。因为它们在初始化后就不会被修改，所以不用担心它们被意外篡改
^1697185325788
保护性程序设计的黄金法则是：“按需知道”原则。尽量在函数内部解决该函数的任务，只共享那些需要共享的变量。除自动存储类别外，其他存储类别也很有用。不过，在使用某类别之前先要考虑一下==是否有必要这样做==。
^1698116893616
