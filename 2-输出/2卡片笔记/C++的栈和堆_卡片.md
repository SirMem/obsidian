---
due: 2023-11-27 

title: C++的栈和堆_卡片
tags:
 
- Cplus 卡片
---
# 🍎重点摘抄
## 引言
在应用程序启动后，操作系统要做的就是将整个程序加载到内存,并分配一大堆物理RAM，以便我们的实际应用程序可以运行。
## 栈和堆的定义
栈和堆是RAM中实际存在的两个区域，栈通常是一个预定义大小的内存区域，通常约为2兆字节左右。而堆也是一个预定义了默认值的区域，但可以扩大，并随着应用程序的进行而改变。

## 栈和堆的使用区别
主要的区别是使用new关键字来分配内存

## 栈
栈的内存分配是连续的，通过栈指针移动，离开作用域后栈的内存全部弹出

在计算机科学中，堆（Heap）和栈（Stack）是两种用于存储和管理程序运行时内存的区域，它们有不同的特性、用途和工作方式。

### 栈（Stack）：
- **定义**：栈是一种线性的数据结构，遵循后进先出（LIFO）的原则，即最后放入的数据最先被取出。
- **工作方式**：栈通常用于存储函数调用时的局部变量、函数参数、返回地址以及一些程序状态的信息。每当一个函数被调用时，该函数的局部变量会被分配在栈上，并在函数执行完毕后自动被释放。栈是一个固定大小的内存区域，操作简单且内存管理由系统自动完成。
- **特点**：栈内存的分配和释放是自动管理的，速度较快。由于其大小有限且连续，所以栈上的空间相对较小。
- 栈顶指针和栈底指针:栈顶指针在变量或者函数加载时向低内存方向移动，栈底指针指向高内存
- 栈帧:当一个函数被调用时，程序需要存储关于该函数的信息，比如参数、局部变量、函数返回地址等。这些信息被组织成一个栈帧，然后被推入程序运行时的调用栈（Call Stack）中。
### 堆（Heap）：
- **定义**：堆是一种动态分配的内存区域，用于存储程序运行时动态分配的数据。堆的分配和释放需要程序员手动控制或使用垃圾回收机制来管理。
- **工作方式**：堆内存通常用于存储动态分配的内存，例如通过 `new` 或 `malloc` 分配的内存，需要手动释放。堆内存的分配和释放不像栈那样有严格的顺序，因此可以更灵活地管理内存。
- **特点**：堆内存的分配和释放需要程序员手动管理，如果没有被正确释放，可能会导致内存泄漏。堆上的空间通常比栈大且分散，分配速度相对较慢。且堆分配的内存没有名称，仅通过指针进行操作。

### 区别：
1. **管理方式**：栈的内存管理是自动的，由系统维护；而堆的内存管理是手动的，由程序员负责。
2. **分配方式**：栈上的内存分配是连续的、固定大小的；堆上的内存分配是动态的、不连续的。
3. **生命周期**：栈上的变量的生命周期与函数调用相关，函数结束时会自动释放；而堆上的变量可以手动控制其生命周期，需要显式释放。
4. **速度**：栈上的内存分配和释放速度更快，因为它是连续的、自动管理的；堆上的内存分配和释放速度较慢，因为它是动态分配的、需要手动管理。

总体来说，栈用于存放程序运行时函数调用和局部变量等较小且固定生命周期的数据，而堆用于存放较大、生命周期不确定的动态分配的数据。两者在内存管理方式、分配速度和使用方式上有着明显的区别。
## 空闲列表
空闲列表（Free List）是一种数据结构，用于管理可用资源的列表，这些资源通常是分配给程序使用的，但目前没有被任何对象或实体所占用。空闲列表跟踪可用资源的位置和状态，以便在需要时可以有效地分配给请求资源的程序或实体。

空闲列表常见的应用之一是在内存管理中。在内存分配中，空闲列表维护着未被程序占用的内存块的信息，包括其起始地址、大小以及是否可用等状态。当程序需要内存时，系统会查找空闲列表以找到合适大小的空闲内存块，并将其分配给请求的程序。分配后，该内存块从空闲列表中移除，并标记为已分配状态。当程序释放内存时，这些内存块会重新加入到空闲列表中，以便下次可以被其他程序使用。

空闲列表不仅仅用于内存管理，还可以用于管理其他资源，比如文件系统中的磁盘块、数据库系统中的空闲页等。它们是一种有效管理可用资源的方式，能够在资源分配和释放时提供快速的访问和更新。

空闲列表的实现可以采用多种数据结构，例如链表、位图、树等。选择合适的数据结构取决于资源管理的需求和性能要求。

当启用应用后，会得到一定数量的物理RAM，程序会维护一个叫做空闲列表(free list)的东西,它是跟踪哪些内存块是空闲的，以及它们在哪里
当使用动态堆内存时，也就是调用new时，new会浏览空闲列表
它调用了整个操作符new,new操作符又调用了malloc,然后要去到空闲列表,检查我们是否有足够的内存，然后得到内存，然后记录已经被拿走了多少内存，有多少已经被分配了，当我们使用完成之后，要delete删除它
cache miss cache hit
## Cache hit(miss)
缓存命中（Cache Hit）和缓存未命中（Cache Miss）是指在处理器或计算机系统的内存层次结构中的缓存操作的结果。

缓存是一种用于临时存储数据的高速存储器，它位于处理器和主内存之间。当处理器需要访问内存中的数据时，它首先检查缓存。如果处理器需要的数据在缓存中已经存在，这个操作就被称为缓存命中（Cache Hit）。这时处理器可以直接从缓存中获取数据，避免了从主内存中读取数据的时间延迟，提高了系统的访问速度。

而当处理器需要的数据不在缓存中时，就会发生缓存未命中（Cache Miss）。这时处理器需要从主内存中加载数据到缓存中，然后再将数据提供给处理器。这个过程需要花费额外的时间，因为要从主内存中读取数据并将其放入缓存，所以相比于缓存命中，缓存未命中的操作会更为耗时。

优化程序的性能通常涉及减少缓存未命中的次数，以提高缓存命中率，从而加快数据访问速度。这包括使用更好的缓存算法、优化数据访问模式以及合理地利用缓存的原则等方法。
堆执行很多命令
## 安全守卫
在 C++ 中，安全守卫（safety guard）通常指在调试模式下，通过添加额外的代码或条件检查来保护程序免受潜在的错误或异常情况的影响。这些守卫可以用于识别潜在的错误、检查边界条件、验证数据结构的完整性等，以帮助开发人员在开发和调试阶段找到和解决问题。


# 📒相关文章




# 🍏引用链接
[[栈和堆excalidraw]]