---
due: 2023-10-16
title: 分配内存_卡片
tags:
  - c语言
  - 卡片
---
# 📖长青笔记(简要概述)
简要说明分配内存的方式


# 📘自我重述




# 🍎重点摘抄

我们前面讨论的存储类别有一个共同之处：在确定用哪种存储类别后，根据已制定好的内存管理规则，将自动选择其作用域和存储期。然而，还有更灵活地选择，即用<font color="#f79646">库函数分配和管理内存</font>。
## malloc()
在程序运行时分配更多的内存。主要的工具是malloc()函数，该函数接受一个参数：所需的内存字节数。malloc()函数会找到合适的空闲内存块，这样的内存是匿名的。也就是说malloc()分配内存，但是不会为其赋名。然而，它确实返回动态分配内存块的<font color="#f79646">首字节地址</font>。因此，可以把该地址赋给一个指针变量，并使用指针访问这块内存。而且，char表示1字节，malloc()的返回类型通常被定义为指向值为char类型的指针。然而，从ANSI C标准开始，C使用一个新的类型：指向void的指针。该类型相当于一个“通用指针”。
malloc()函数可用于返回指向数组的指针、指向结构的指针等，所以通常该函数的返回值会被强制转换为匹配的类型。如果 malloc()分配内存失败，将返回空指针。
另一方面，用malloc()创建的数组不必局限 在一个函数内访问。例如，可以这样做：被调函数创建一个数组并返回指 针，供主调函数访问，然后主调函数在末尾调用free()释放之前被调函数分 配的内存。另外，free()所用的指针变量可以与 malloc()的指针变量不同，但 是两个指针必须储存相同的地址。
### malloc()应用例
我们试着用 malloc()创建一个数组。除了用 malloc()在程序运行时请求一块内存，还需要一个指针记录这块内存的位置。例如，考虑下面的代码：
```
double * ptd;
ptd = (double *) malloc(30 * sizeof(double));
```
以上代码为30个double类型的值请求内存空间，并设置ptd指向该位置。
注意，指针ptd被声明为指向一个double类型，而不是指向内含30个double类型值的块。数组名是该数组首元素的地址。因此，如果让ptd指向这个块的首元素，便可像使用数组名一样使用它。也就是说，可以使用表达式ptd\[0]访问该块的首元素，ptd\[1]访问第2个元素，以此类推。根据前面所学的知识，可以使用数组名来表示指针，也可以用指针来表示数组。

## 三种创建数组的方法
声明数组时，用常量表达式表示数组的维度，用数组名访问数组的元素。可以用静态内存或自动内存创建这种数组。
声明变长数组（C99新增的特性）时，用变量表达式表示数组的维度，用数组名访问数组的元素。具有这种特性的数组只能在自动内存中创建。
声明一个指针，调用malloc()，将其返回值赋给指针，使用指针访问数组的元素。该指针可以是静态的或自动的。
使用第2种和第3种方法可以创建动态数组（dynamic array）。这种数组和普通数组不同，可以在程序运行时选择数组的大小和分配内存。例如，假设n是一个整型变量。在C99之前，不能这样做:double item\[n]; // C99之前：n不允许是变量。但可以这样:ptd = (double\*) malloc(n * sizeof(double)); //可以。这比变长数组更灵活

## free()
通常，malloc()要与free()配套使用。free()函数的参数是之前malloc()返回的地址，该函数释放之前malloc()分配的内存。因此，动态分配内存的存储期从调用malloc()分配内存到调用free()释放内存为止。设想malloc()和free()管理着一个内存池。每次调用malloc()分配内存给程序使用，每次调用free()把内存归还内存池中，这样便可重复使用这些内存。free()的参数应该是一个指针，指向由 malloc()分配的一块内存。

### free()的重要性
静态内存的数量在编译时是固定的，在程序运行期间也不会改变。自动变量使用的内存数量在程序执行期间自动增加或减少。但是动态分配的内存数量只会增加，除非用 free()进行释放。
```
int main()
{
double glad[2000];
int i;
...
for (i = 0;i < 1000;i++)
{
gobble(glad, 2000);
...
}
void gobble(double ar[],int n)
{
double * temp = (double *) malloc( n * sizeof(double));
.../* free(temp); // 假设忘记使用free() */
}
```
第1次调用gobble()时，它创建了指针temp，并调用malloc()分配了16000字节的内存（假设double为8 字节）。假设如代码注释所示，遗漏了free()。当函数结束时，作为自动变量的指针temp也会消失。但是它所指向的16000字节的内存却仍然存在。由于temp指针已被销毁，所以无法访问这块内存，它也不能被重复使用，因为代码中没有调用free()释放这块内存。

第2次调用gobble()时，它又创建了指针temp，并调用malloc()分配了16000字节的内存。第1次分配的16000字节内存已不可用，所以malloc()分配了另外一块16000字节的内存。当函数结束时，该内存块也无法被再访问和再使用。

循环要执行1000次，所以在循环结束时，内存池中有1600万字节被占
用。实际上，也许在循环结束之前就已耗尽所有的内存。
## exit()
如果内存分配失败，可以调用 exit()函数结束程序，其原型在stdlib.h中。EXIT_FAILURE的值也被定义在stdlib.h中。标准提供了两个返回值以保证在所有操作系统中都能正常工作:EXIT_SUCCESS（或者，相当于0）表示普通的程序结束， EXIT_FAILURE 表示程序异常中止。

## calloc()
```
calloc()的用法
long *newmem;
newmem = (long*)calloc(100,sizeof(long));
```
与malloc()类似,在ANSI之前，calloc()也返回指向char的指针；在ANSI之后，返回指向void的指针。如果要储存不同的类型，应使用强制类型转换运算符。calloc()函数接受两个无符号整数作为参数（ANSI规定是size_t类型）。第1个参数是所需的存储单元数量，第2个参数是存储单元的大小（以字节为单位）。long为4字节，所以，前面的代码创建了100个4字节的存储单元，总共400字节。可以说calloc()是创建了多个块，而malloc()则是创建了一个总和的块。
calloc()函数还有一个特性：它把块中的所有位都设置为0（注意，在某些硬件系统中，不是把所有位都设置为0来表示浮点值0）。
free()函数也可用于释放calloc()分配的内存。

## 动态内存分配和变长数组
[[指针和数组]]
变长数组（VLA）和调用 malloc()在功能上有些重合。例如，两者都可用于创建在运行时确定大小的数组：
```
int vlamal()
{
int n;
int * pi;
scanf("%d", &n);
pi = (int *) malloc (n * sizeof(int));
int ar[n];// 变长数组
pi[2] = ar[2] = -5;
...
}
```
因此，程序在离开变长数组定义所在的块时（该例中，即vlamal()函数结束时），变长数组占用的内存空间会被自动释放，不必使用 free()。另一方面，用malloc()创建的数组不必局限在一个函数内访问。例如，可以这样做：被调函数创建一个数组并返回指针，供主调函数访问，然后主调函数在末尾调用free()释放之前被调函数分配的内存。另外，free()所用的指针变量可以与 malloc()的指针变量不同，但是两个指针必须储存相同的地址。但是，不能释放同一块内存两次。

### 多维数组
```
int n = 5;
int m = 6;
int ar2[n][m]; // n×m的变长数组（VLA）
int (* p2)[6]; // C99之前的写法
int (* p3)[m]; // 要求支持变长数组
p2 = (int (*)[6]) malloc(n * 6 * sizeof(int)); // n×6 数组
p3 = (int (*)[m]) malloc(n * m * sizeof(int)); // n×m 数组（要求支持变长数
组）
ar2[1][2] = p2[1][2] = 12;
```
先复习一下指针声明。由于malloc()函数返回一个指针，所以p2必须是
一个指向合适类型的指针。第1个指针声明：
int (* p2)\[6]; // C99之前的写法
表明p2指向一个内含6个int类型值的数组。因此，p2\[i]代表一个由6个整
数构成的元素，p2[i][j]代表一个整数。
第2个指针声明用一个变量指定p3所指向数组的大小。因此，p3代表一
个指向变长数组的指针，这行代码不能在C90标准中运行。


## 存储类别和动态内存分配

# 📒相关文章


