---
due: 2023-11-01
title: 引用_卡片
tags:
  - 卡片
  - Cplus
---
# 🍎重点摘抄
## 定义
引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。
## 声明引用
```cpp
type& referenceName = originalVariable;
```
其中，`type` 是变量的数据类型，`referenceName` 是引用的名称，`originalVariable` 是要引用的变量。上述格式中，“&”并不是取地址操作符，而是起标识作用，标识所定义的标识符是一个引用。引用声明完成以后相当于目标变量有两个名称。
## 注意
引用在定义时必须初始化，如intb:是错误的。
●引用在初始化时只能绑定左值不能绑定常量值。
●引用一旦初始化，其值就不能再更改，即不能再做别的变量的引用
●数组不能定义引用，因为数组是一组数据，无法定义其别名。
## 特性
### 引用变量修改原变量
```cpp
#include <iostream>

int main() {
    int originalVar = 42;
    int& refVar = originalVar;

    std::cout << "originalVar: " << originalVar << std::endl;
    std::cout << "refVar: " << refVar << std::endl;

    // 修改引用也会修改原始变量
    refVar = 99;
    std::cout << "originalVar after modification: " << originalVar << std::endl;
    std::cout << "refVar after modification: " << refVar << std::endl;

    return 0;
}
```
在上面的示例中，`refVar` 是对`originalVar` 的引用，它们引用相同的内存位置。因此，如果您修改`refVar`，原始变量`originalVar` 也会被修改。

## 应用
1. 别名：引用是变量的别名，允许您使用更直观的方式访问变量，而不需要复制数据。
    
2. 避免不必要的复制：通过传递引用而不是副本，可以提高函数的性能，避免在函数调用时复制大量数据。
    
3. 修改原始数据：通过引用，您可以直接修改原始变量，而不需要返回修改后的值。
    
4. 用于函数参数：引用经常用于函数参数，以允许函数修改其参数的值。原始变量也被修改
    
5. 避免指针复杂性：与指针不同，引用不能为NULL，这有助于减少空指针错误。

## 引用和指针的区别
1. 别名 vs. 指针：
    
    - 引用是变量的别名，它和被引用的变量在使用时没有显式的解引用操作，使代码更加直观和自然。
    - 指针是一个包含另一个变量内存地址的变量，需要使用解引用操作符(*)来访问目标变量的值。
2. 内存地址：
    
    - 引用在内部实际上是目标变量的地址的另一个名称，因此它们没有自己的地址，也没有指针的那种地址运算。
    - 指针有自己的内存地址，因此指针本身也可以被操作，包括指针的地址运算和指针的值（所指向的变量的地址）。
3. 空值：
    
    - 引用不可以为空，一旦引用绑定到一个变量，它将始终引用该变量，无法指向空值或无效的内存。
    - 指针可以为空，即指向nullptr，用来表示没有有效的目标。
4. 重新绑定：
    
    - 引用在绑定后无法重新绑定到其他变量，它们在生命周期内始终引用相同的变量。
    - 指针可以在运行时重新分配到不同的地址，即可以指向不同的变量或空。
5. 安全性：
    
    - 引用通常更安全，因为它们不会引起空指针错误，避免了一些指针操作可能导致的错误。
    - 指针需要更多的谨慎，因为它们可以指向任何地方，包括无效内存地址。
6. 语法：
    
    - 引用在声明时需要初始化，并且不能改变其引用目标。例如：`int& ref = originalVar;`
    - 指针可以在声明后初始化，也可以在运行时重新分配给其他地址。例如：`int* ptr = &originalVar;`
7. 运算符的使用：
    
    - 引用没有地址运算符（如`&` 和 `*`）。
    - 指针使用地址运算符来获取地址和解引用操作符来访问目标变量。


综上所述，引用提供了更直观的方式来访问变量，并且通常更安全，但它们在使用上更受限制。指针具有更大的灵活性，但也需要更多的谨慎来避免潜在的问题，如空指针引起的运行时错误。选择使用引用还是指针通常取决于特定的需求和编程情境。





## 返回值引用
```cpp
#include <iostream>
 
using namespace std;
 
double vals[] = {10.1, 12.6, 33.1, 24.1, 50.0};
 
double& setValues(int i) {  
   double& ref = vals[i];    
   return ref;   // 返回第 i 个元素的引用，ref 是一个引用变量，ref 引用 vals[i]
 
 
}
 
// 要调用上面定义函数的主函数
int main ()
{
 
   cout << "改变前的值" << endl;
   for ( int i = 0; i < 5; i++ )
   {
       cout << "vals[" << i << "] = ";
       cout << vals[i] << endl;
   }
 
   setValues(1) = 20.23; // 改变第 2 个元素
   setValues(3) = 70.8;  // 改变第 4 个元素
 
   cout << "改变后的值" << endl;
   for ( int i = 0; i < 5; i++ )
   {
       cout << "vals[" << i << "] = ";
       cout << vals[i] << endl;
   }
   return 0;
} //返回值引用交换数组值
``` 

## 类似于指针函数的引用函数
`inline T const& Max (T const& a, T const& b)` 表示定义了一个模板函数，这个函数接受两个参数 `a` 和 `b`，这两个参数的类型都是 `T` 类型的常量引用（`T const&`），并且函数返回一个 `T` 类型的常量引用。这意味着这个函数用于比较两个值，并返回其中较大的值的引用，而且参数和返回值都是模板类型 `T` 的常量引用。

## 链式调用
## 逆向引用

# 📒相关文章
2



# 🍏引用链接

