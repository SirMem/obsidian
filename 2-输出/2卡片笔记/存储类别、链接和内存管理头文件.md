---
due: 2023-10-11
title: 存储类别、链接和内存管理
tags:
  - C语言
---
# 📖长青笔记(简要概述)



# 📘自我重述




# 🍎重点摘抄
## 本章学习内容
关键字：auto、extern、static、register、const、volatile、restricted、
、Thread_local、Atomic
函数：rand()、srand()、time()、malloc()、calloc()、free()
如何确定变量的作用域（可见的范围）和生命期（它存在多长时间）
设计更复杂的程序
## 存储类别

从硬件方面来看，被储存的每个值都占用一定的物理内存，C 语言把这样的一块内存称为对象（object）。对象可以存储一个或多个值。
从软件方面来看，程序需要一种方法访问对象。这可以通过声明变量来完成：如 
int entity =3; 
### 标识符
该声明创建了一个名为entity的标识符（identifier。标识符entity即是软件（即C程序）指定硬件内存中的对象的方式。该声明还提供了储存在对象中的值。一般而言，那些指定对象(地址)的表达式被称为左值（第5章介绍过）。
### 左值(地址指针):
*pt既是表达式也是左值。按照这个思路，ranks + 2 * entity既不是标识符
（不是名称），也不是左值（它不指定内存位置上的内容）。但是表达式*
(ranks + 2 * entity)是一个左值，因为它的确指定了特定内存位置的值，即
ranks数组的第7个元素。

### 右值
### 例子:
考虑此声明:const char * pc = "Behold a string literal!";
程序根据该声明把相应的字符串字面量储存在内存中，内含这些字符值
的数组就是一个对象。由于数组中的每个字符都能被单独访问，所以每个字
符也是一个对象。该声明还创建了一个标识符为pc的对象，储存着字符串的
地址。由于可以设置pc重新指向其他字符串，所以标识符pc是一个可修改的
左值。const只能保证被pc指向的字符串内容不被修改，但是无法保证pc不指
向别的字符串。由于*pc指定了储存'B'字符的数据对象，所以*pc 是一个左
值，但不是一个可修改的左值。与此类似，因为字符串字面量本身指定了储
存字符串的对象，所以它也是一个左值，但不是可修改的左值。

## 作用域
指一个变量的作用范围。一个C变量的作用域可以是块作用域、函数作用域、函数原型作用域或文件作用域。
### 全局作用域(文件作用域)
全局作用域的变量都是全局变量，在页面中的任意地方都可以访问和修改。
### 局部作用域
局部作用域也称为函数作用域。调用函数时创建函数作用域，函数执行完毕后，函数作用域销毁
每调用一次函数就会创建一个新的函数作用域，它们之间是相互独立的。在函数作用域中可以访问到全局作用域中的变量；在全局作用域中无法访问到函数作用域的变量。
当在函数作用域中操作一个变量时，它会先在自身的作用域中去找，若有则直接使用；若没有则向上一级作用域中寻找。直接找到全局作用域，若全局作用域仍未找到，则直接报错：Reference Error
### 块级作用域
在 {} 之间定义的 js 代码是块级作用域
注意：在块级作用域里定义的变量是块级变量，只在该块级作用域中有效。
为适应这个新特性，C99把块的概念扩展到包括for循环、while循环、
do while循环和if语句所控制的代码，即使这些代码没有用花括号括起来，
也算是块的一部分。所以，上面for循环中的变量i被视为for循环块的一部
分，它的作用域仅限于for循环。一旦程序离开for循环，就不能再访问i。
### 文件作用域：
任何在所有代码块之外声明的标识符都具有文件作用域(file scope)。它表示这些标识符从它们的声明之处直到它所在的源文件结尾处都是可以访问的。在文件中定义的函数名也具有文件作用域，因为函数名本身并不属于任何代码块。在头文件中编写并通过#include指令包含到其他文件中的声明就好像它们是直接写在那些文件中一样。它们的作用域并不局限于头文件的文件尾
## 翻译单元和文件
编译器源代码文件和所有的头文件都看成是一个包含信息的单独文件。这个文件被称为翻译单元（translation unit）。描述一个具有文件作用域的变量时，它的实际可见范围是整个翻译单元。如果程序由多个源代码文件组成，那么该程序也将由多个
翻译单元组成。每个翻译单元均对应一个源代码文件和它所包含的文件。

## 链接
C 变量有 3 种链接属性：外部链接、内部链接或无链接。
具有块作用域、函数作用域或函数原型作用域的变量都是无链接
变量。这意味着这些变量属于定义它们的块、函数或原型私有。具有文件作
用域的变量可以是外部链接或内部链接。外部链接变量可以在多文件程序中
使用，内部链接变量只能在一个翻译单元中使用
C 标准用“内部链接的文件作用域”描述仅限于一个翻译单元（即一个源
代码文件和它所包含的头文件）的作用域，用“外部链接的文件作用域”描述
可延伸至其他翻译单元的作用域。

如何知道文件作用域变量是内部链接还是外部链接？可以查看外部定义
中是否使用了存储类别说明符static
![[nPpXHawlbwqKtrsN-b5e4ce1e-2b98-f7ad-e250-ad3ab89e0fc6.png|1006]]
864

## 存储期
作用域和链接描述了标识符的可见性。存储期描述了通过这些标识符访
问的对象的生存期。C对象有4种存储期：静态存储期、线程存储期、自动
存储期、动态分配存储期。存储期是指对象在内存中保留了多长时间.

### 静态存储期
如果对象具有静态存储期，那么它在程序的执行期间一直存在。文件作
用域变量具有静态存储期。注意，对于文件作用域变量，关键字 static表明
了其链接属性，而非存储期。以 static声明的文件作用域变量具有内部链
接。但是无论是内部链接还是外部链接，所有的文件作用域变量都具有静态
存储期。

### 线程存储期
线程存储期用于并发程序设计，程序执行可被分为多个线程。具有线程
存储期的对象，从被声明时到线程结束一直存在。以关键字_Thread_local声
明一个对象时，每个线程都获得该变量的私有备份。

### 自动存储期
块作用域的变量通常都具有自动存储期。当程序进入定义这些变量的块
时，为这些变量分配内存；当退出这个块时，释放刚才为变量分配的内存。
这种做法相当于把自动变量占用的内存视为一个可重复使用的工作区或暂存
区。例如，一个函数调用结束后，其变量占用的内存可用于储存下一个被调
用函数的变量。
变长数组稍有不同，它们的存储期从声明处到块的末尾，而不是从块的开始处到块的末尾。


### 块作用域的存储期

我们到目前为止使用的局部变量都是自动类别。例如，在下面的代码中，变量number和index在每次调用bore()函数时被创建，在离开函数时被销毁
```
void bore(int number)
{
int index;
for (index = 0;index < number;index++)
puts("They don't make them the way they used to.\n");
return 0;
}
```
然而，块作用域变量也能具有静态存储期。为了创建这样的变量，要把
变量声明在块中，且在声明前面加上关键字static
```
void more(int number)
{
int index;
static int ct = 0;
...
return 0;
}
```
这里，变量ct储存在静态内存中，它从程序被载入到程序结束期间都存
在。但是，它的作用域定义在more()函数块中。只有在执行该函数时，程序
才能使用ct访问它所指定的对象（但是，该函数可以给其他函数提供该存储
区的地址以便间接访问该对象，例如通过指针形参或返回值）

### 作用域、链接、存储期再说明
C 使用作用域、链接和存储期为变量定义了多种存储方案。本书不涉及
并发程序设计，所以不再赘述这方面的内容。已分配存储期在本章后面介
绍。因此，剩下5种存储类别：自动、寄存器、静态块作用域、静态外部链
接、静态内部链接
![[nPpXHawlbwqKtrsN-85e625b7-c654-1add-ff60-5a20b9e6ac67.png|986]]
块作用域和无链接意味着只有在变量定义所在的块中才能通过变量名访
问该变量（当然，参数用于传递变量的值和地址给另一个函数，但是这是间
接的方法）。另一个函数可以使用同名变量，但是该变量是储存在不同内存
位置上的另一个变量。
变量具有自动存储期意味着，程序在进入该变量声明所在的块时变量存
在，程序在退出该块时变量消失。原来该变量占用的内存位置现在可做他
用。

### 嵌套块
```
块中声明的变量仅限于该块及其包含的块使用。
int loop(int n)
{
int m; // m 的作用域
scanf("%d", &m);

{
int i; // m 和 i 的作用域
for (i = m;i < n;i++)
puts("i is local to a sub-block\n");

}

return m; // m 的作用域，i 已经消失
}
```
如果内层块中声明的变量与外层块中的变量同名会怎样？内层块会隐藏
外层块的定义。但是离开内层块后，外层块变量的作用域又回到了原来的作用域。
## 自动存储类别的自动变量
属于自动存储类别的变量具有自动存储期、块作用域且无链接。默认情
况下，声明在块或函数头中的任何变量都属于自动存储类别。为了更清楚地
表达你的意图（例如，为了表明有意覆盖一个外部变量定义，或者强调不要
把该变量改为其他存储类别），可以显式使用关键字auto,关键字auto是存储类别说明符（storage-class specifier）。

## 特殊情况
### 1.没有花括号的块
前面提到一个C99特性：作为循环或if语句的一部分，即使不使用花括
号（{}），也是一个块。更完整地说，整个循环是它所在块的子块（sub-
block），循环体是整个循环块的子块。

## 自动变量的初始化
自动变量不会初始化，除非显式初始化它

## 寄存器变量
变量通常储存在计算机内存中。如果幸运的话，寄存器变量储存在CPU
的寄存器中，或者概括地说，储存在最快的可用内存中。与普通变量比，
访问和处理这些变量的速度更快。由于寄存器变量储存在寄存器而非内存
中，所以无法获取寄存器变量的地址。寄存器变量和自动变量都一样。也就是说，它们都是块作用域、无链接和自动存储期。使用==存储
类别说明符register==便可声明寄存器变量
因为声明变量为register类别与直接命令
相比更像是一种请求。编译器必须根据寄存器或最快可用内存的数量衡量你
的请求，或者直接忽略你的请求，所以可能不会如你所愿。在这种情况下，
寄存器变量就变成普通的自动变量。即使是这样，仍然不能对该变量使用地
址运算符。可声明为register的数据类型有限。例如，处理器中的寄存器可能没有足
够大的空间来储存double类型的值。

## 块作用域的静态变量
静态的意思是该变量在内存中原地不动，并不是说它的值不变。具
有文件作用域的变量自动具有（也必须是）静态存储期。前面提到过，可以
创建具有静态存储期、块作用域的局部变量。这些变量和自动变量一样，具
有相同的作用域，但是程序离开它们所在的函数后，这些变量不会消失。也
就是说，这种变量具有块作用域、无链接，但是具有静态存储期。
不能在函数的形参中使用static

## 外部链接的静态变量
外部链接的静态变量具有文件作用域、外部链接和静态存储期。该类别
有时称为外部存储类别（external storage class），属于该类别的变量称为外
部变量（external variable）。把变量的定义性声明（defining declaration）放
在在所有函数的外面便创建了外部变量。为了指出该函数使用了外部
变量，可以在函数中用关键字extern再次声明。如果一个源代码文件使用的
外部变量定义在另一个源代码文件中，则必须用extern在该文件中声明该变
量。
```
example:
int Errupt; /* 外部定义的变量 */
double Up[100];/* 外部定义的数组 */
extern char Coal;/* 如果Coal被定义在另一个文件， */
/*则必须这样声明*/
void next(void);
int main(void)
{
extern int Errupt;/* 可选的声明*/
extern double Up[];/* 可选的声明*/
...

}
void next(void)
{
...
}
```
注意，在main()中声明Up数组时（这是可选的声明）不用指明数组大
小，因为第1次声明已经提供了数组大小信息。main()中的两条 extern 声明完
全可以省略，因为外部变量具有文件作用域，所以Errupt和Up从声明处到文
件结尾都可见。它们出现在那里，仅为了说明main()函数要使用这两个变
量。
```
如果省略掉函数中的extern关键字，相当于创建了一个自动变量。去掉
下面声明中的extern
extern int Errupt;
便成为：
int Errupt;
```
这使得编译器在 main()中创建了一个名为 Errupt 的自动变量。它是一个
独立的局部变量，与原来的外部变量Errupt不同。该局部变量仅main()中可
见，但是外部变量Errupt对于该文件的其他函数（如 next()）也可见。简而
言之，在执行块中的语句时，块作用域中的变量将“隐藏”文件作用域中的同
名变量。如果不得已要使用与外部变量同名的局部变量，可以在局部变量的
声明中使用 auto 存储类别说明符明确表达这种意图。
外部变量具有静态存储期。因此，无论程序执行到main()、next()还是其
他函数，数组Up及其值都一直存在。

### 初始化外部变量
外部变量和自动变量类似，也可以被显式初始化。与自动变量不同的
是，如果未初始化外部变量，它们会被自动初始化为 0。与自动变量的情况不同，只能使用常量表达式初始化
文件作用域变量
```
example
int x = 10; // 没问题，10是常量
int y = 3 + 20; // 没问题，用于初始化的是常量表达式
size_t z = sizeof(int); //没问题，用于初始化的是常量表达式
int x2 = 2 * x; // 不行，x是变量
（只要不是变长数组，sizeof表达式可被视为常量表达式。）
```


### 使用外部变量
```
example
/* global.c -- 使用外部变量 */
#include <stdio.h>
int units = 0;
/* 外部变量 */
void critic(void);
int main(void)
{
extern int units; /* 可选的重复声明 */
printf("How many pounds to a firkin of butter?\n");
scanf("%d", &units);
while (units != 56)
critic();
printf("You must have looked it up!\n");
return 0;
}
void critic(void)
{
/* 删除了可选的重复声明 */
printf("No luck, my friend. Try again.\n");
scanf("%d", &units);
}
下面是该程序的输出示例：
How many pounds to a firkin of butter?
14
No luck, my friend. Try again.
56
You must have looked it up!
```

while循环结束时，
main()也知道units的新值。所以main()函数和critic()都可以通过标识符units访
问相同的变量。用C的术语来描述是， units具有文件作用域、外部链接和静
态存储期。

把units定义在所有函数定义外面（即外部），units便是一个外部变量，
对units定义下面的所有函数均可见。因此，critics()自定函数可以直接使用units变量。

本例中，以上声明主要是为了指出该函数要使用这个外部变量。存储类
别说明符extern告诉编译器，该函数中任何使用units的地方都引用同一个定
义在函数外部的变量。再次强调，main()和critic()使用的都是外部定义的
units。

### 外部名称限定
C99和C11标准都要求编译器识别局部标识符的前63个字符和外部标识
符的前31个字符。这修订了以前的标准，即编译器识别局部标识符前31个字
符和外部标识符前6个字符。你所用的编译器可能还执行以前的规则。外部
变量名比局部变量名的规则严格，是因为外部变量名还要遵循局部环境规
则，所受的限制更多。

### 4.定义和声明
```
example
int tern = 1; /* tern被定义 */
main()
{
extern int tern; /* 使用在别处定义的tern */
```
这里，tern被声明了两次。第1次声明为变量预留了存储空间，该声明构
成了变量的定义。第2次声明只告诉编译器使用之前已创建的tern变量，所以
这不是定义。第1次声明被称为定义式声明（defining declaration），第2次声
明被称为引用式声明（referencing declaration）。关键字extern表明该声明不
是定义，因为它指示编译器去别处查询其定义。
```
假设这样写
extern int
tern;
int main(void)
{
```
编译器会假设 tern 实际的定义在该程序的别处，也许在别的文件中。该
声明并不会引起分配存储空间。因此，不要用关键字extern创建外部定义，
只用它来引用现有的外部定义。

```
只能定义一次
// file_one.c
char permis = 'N';
...
// file_two.c
extern char permis = 'Y'; /* 错误 */
```
file_two中的声明是错误的，因为file_one.c中的定义式声明已经创建并
初始化了permis。

## 内部链接的静态变量
该存储类别的变量具有静态存储期、文件作用域和内部链接。在所有函
数外部（这点与外部变量相同），用存储类别说明符static定义的变量具有
这种存储类别
```
example
static int svil = 1; // 静态变量，内部链接
int main(void){

}
```
这种变量过去称为外部静态变量（external static variable），但是这个
术语有点自相矛盾（这些变量具有内部链接）。但是，没有合适的新简称，
所以只能用内部链接的静态变量（static variable with internal linkage）。
```
example
int traveler = 1; // 外部链接
static int stayhome = 1; // 内部链接
int main()
{
extern int traveler;// 使用定义在别处的 traveler
extern int stayhome; // 使用定义在别处的 stayhome
...
```
对于该程序所在的翻译单元，trveler和stayhome都具有文件作用域，但
是只有traveler可用于其他翻译单元（因为它具有外部链接）。这两个声明
都使用了extern关键字，指明了main()中使用的这两个变量的定义都在别处，
但是这并未改变stayhome的内部链接属性。
## 多文件
只有当程序由多个翻译单元组成时，才体现区别内部链接和外部链接的
重要性。接下来简要介绍一下。
复杂的C程序通常由多个单独的源代码文件组成。要共享一个外部变量。C通过在一个文件中进行定义式声明，然后在其他文件中进行引用式声明来实现共享。也就是说，除了一个定义式声明外，其他声明都要使用extern关键字。而且，只有定义式声明才能初始化变量。
如果外部变量定义在一个文件中，那么其他文件在使用该变量之
前必须先声明它（用 extern关键字）。也就是说，在某文件中对外部变量进
行定义式声明只是单方面允许其他文件使用该变量，其他文件在用extern声
明之前不能直接使用它。

## 存储类别说明符
关键字static和extern的含义取决于上下文。C语言有6个关键字作为存储类别说明符：auto、register、static、extern、\_Thread_local和typedef。
auto说明符表明变量是自动存储期，只能用于块作用域的变量声明中。
由于在块中声明的变量本身就具有自动存储期，所以使用auto主要是为了明
确表达要使用与外部变量同名的局部变量的意图。
register 说明符也只用于块作用域的变量，它把变量归为寄存器存储类
别，请求最快速度访问该变量。同时，还保护了该变量的地址不被获取。
用 static 说明符创建的对象具有静态存储期，载入程序时创建对象，当
程序结束时对象消失。如果static 用于文件作用域声明，作用域受限于该文
件。如果 static 用于块作用域声明，作用域则受限于该块。因此，只要程序
在运行对象就存在并保留其值，但是只有在执行块内的代码时，才能通过标识符访问。块作用域的静态变量无链接。文件作用域的静态变量具有内部链
接。
extern 说明符表明声明的变量定义在别处。如果包含 extern 的声明具有
文件作用域，则引用的变量必须具有外部链接。如果包含 extern 的声明具有
块作用域，则引用的变量可能具有外部链接或内部链接，这接取决于该变量
的定义式声明。


## 小结
```
example
// parta.c --- 不同的存储类别
// 与 partb.c 一起编译
#include <stdio.h>
void report_count();
void accumulate(int k);
int count = 0; // 文件作用域，外部链接
int main(void)
{
int value; // 自动变量
register int i; // 寄存器变量
printf("Enter a positive integer (0 to quit): ");
while (scanf("%d", &value) == 1 && value > 0)
{
++count; // 使用文件作用域变量
for (i = value;i >= 0;i--)
accumulate(i);

printf("Enter a positive integer (0 to quit): ");
}
report_count();
return 0;
}
void report_count()
{
printf("Loop executed %d times\n", count);
}




程序清单12.6 partb.c程序
// partb.c -- 程序的其余部分
// 与 parta.c 一起编译
#include <stdio.h>
extern int count; // 引用式声明，外部链接
static int total = 0; // 静态定义，内部链接
void accumulate(int k); // 函数原型

void accumulate(int k)// k 具有块作用域，无链接
{
static int subtotal = 0; // 静态，无链接
if (k <= 0)
{
printf("loop cycle: %d\n", count);
printf("subtotal: %d;total: %d\n", subtotal,total);
subtotal = 0;
}
else
{
subtotal += k;
total += k;
}
}
```
在该程序中，块作用域的静态变量subtotal统计每次while循环传入
accumulate()函数的总数，具有文件作用域、内部链接的变量 total 统计所有
传入 accumulate()函数的总数。当传入负值时， accumulate()函数报告total和
subtotal的值，并在报告后重置subtotal为0。由于parta.c调用了 accumulate()函
数，所以必须包含 accumulate()函数的原型。而 partb.c 只包含了accumulate()
函数的定义，并未在文件中调用该函数，所以其原型为可选（即省略原型也
不影响使用）。该函数使用了外部变量count 统计main()中的while循环迭代
的次数（顺带一提，对于该程序，没必要使用外部变量把 parta.c 和 partb.c
的代码弄得这么复杂）。在 parta.c 中，main()和report_count()共享count。


## 存储类别和函数
函数也有存储类别，可以是外部函数（默认）或静态函数。C99 新增了
第 3 种类别——内联函数;
外部函数可以被其他文件的函数访问，但是静态函数只能用于其定义所在的文件
```
example
double gamma(double); /* 该函数默认为外部函数 */
static double beta(int,int);
extern double delta(double,int);
```
在同一个程序中，其他文件中的函数可以调用gamma()和delta()，但是不能调用beta()，因为以static存储类别说明符创建的函数属于特定模块私有。这样做避免了名称冲突的问题，由于beta()受限于它所在的文件，所以在其他文件中可以使用与之同名的函数。
通常的做法是：用 extern 关键字声明定义在其他文件中的函数。这样做
是为了表明当前文件中使用的函数被定义在别处。除非使用static关键字，
否则一般函数声明都默认为extern。

## 存储类别的选择
对于“使用哪种存储类别”的回答绝大多数是“自动存储类别”，要知道默
认类别就是自动存储类别。初学者会认为外部存储类别很不错，为何不把所
有的变量都设置成外部变量，这样就不必使用参数和指针在函数间传递信息
了。然而，这背后隐藏着一个陷阱。如果这样做，A()函数可能违背你的意
图，私下修改B()函数使用的变量。多年来，无数程序员的经验表明，随意
使用外部存储类别的变量导致的后果远远超过了它所带来的便利。
唯一例外的是const数据。因为它们在初始化后就不会被修改，所以不
用担心它们被意外篡改
保护性程序设计的黄金法则是：“按需知道”原则。尽量在函数内部解决
该函数的任务，只共享那些需要共享的变量。除自动存储类别外，其他存储
类别也很有用。不过，在使用某类别之前先要考虑一下是否有必要这样做。